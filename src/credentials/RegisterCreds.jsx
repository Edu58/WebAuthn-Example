///////// START UTIL FUNCTIONS /////////
// easy way to go from string to ByteArray
const enc = new TextEncoder();

// another function to go from string to ByteArray, but we first encode the
// string as base64 - note the use of the atob() function
function strToBin(str) {
    return Uint8Array.from(atob(str), c => c.charCodeAt(0));
}

// function to encode raw binary to string, which is subsequently
// encoded to base64 - note the use of the btoa() function
function binToStr(bin) {
    return btoa(new Uint8Array(bin).reduce(
        (s, byte) => s + String.fromCharCode(byte), ''
    ));
}

const createCreds = async () => {
    // Should be generated by your server
    const publicKey = {
        'challenge': enc.encode('JGSFUYDFGSIOHFOPSIJDF84Y39R4Y37RTHFJKSFNSIODF8SDBJhDSIUGV8S7DFVSDVS'),
        'rp': {
            name: "Edwin's WebAuthn Demo",

        },
        'user': {
            'id': enc.encode('edwin1999'),
            'name': "edwin",
            'displayName': "Edwin",
        },
        'authenticatorSelection': {
            userVerification: "preferred",
        },
        'attestation': "direct",
        'pubKeyCredParams': [
            { 'type': 'public-key', 'alg': -7 },
            { 'type': 'public-key', 'alg': -257 }
        ],
    }

    const res = await navigator.credentials.create({ publicKey })

    localStorage.setItem('rawID', binToStr(res.rawId))
    localStorage.getItem('id', binToStr(res.id))
}

const validateCreds = async () => {
    ////// START server generated info //////
    // Usually the below publicKey object is constructed on your server
    // here for DEMO purposes only
    const rawID = localStorage.getItem('rawID')
    const AUTH_CHALLENGE = "somethingveryrandom"

    const publicKey = {
        'rpId': window.location.hostname, // your domain
        'challenge': enc.encode(AUTH_CHALLENGE), // atleast 16 bytes
        'allowCredentials': [{
            'id': strToBin(rawID),
            'type': 'public-key'
        }],
        'authenticatorSelection': {
            'userVerification': "preferred"
        }
    }
    ////// END server generated info //////

    // broser receives the public key and passes it to webauthn get
    const res = await navigator.credentials.get({ publicKey })

    // here we build an object containing the results, to be sent to the server
    // usually "extractedData" is POSTed to your server
    const extractedData = {
        'id': res.id,
        'rawId': binToStr(res.rawId),
        'clientDataJSON': binToStr(res.response.clientDataJSON)
    }

    // Usually done on the server, this is where you make your auth checks
    // here for DEMO purposes only
    const dataFromClient = JSON.parse(atob(extractedData.clientDataJSON));
    const retrievedChallenge = atob(dataFromClient.challenge);
    const retrievedOrigin = dataFromClient.origin;

    // At MINIMUM, your auth checks should be:
    // 1. Check that the retrieved challenge matches the auth challenge you sent to the client, as we do trivially below
    // 2. Check that "retrievedOrigin" matches your domain - otherwise this might be a phish - not shown here
    console.log(retrievedChallenge);
    if (retrievedChallenge == AUTH_CHALLENGE) {
        alert("Authorized");
    } else {
        alert("Unauthorized");
    }
}
export { createCreds, validateCreds }